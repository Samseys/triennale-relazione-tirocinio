\chapter{Ristrutturazione e traduzione dello schema}
In questo capitolo procederemo alla preparazione dello schema per poi tradurlo direttamente in uno schema relazionale per PostgreSQL, specificando anche delle soluzioni per
rispettare i vincoli esterni definiti.
\section{Ristrutturazione dello schema Entity-Relationship}
Procediamo alla ristrutturazione dello schema ER prima di tradurlo direttamente nello schema relazionale:
\begin{itemize}
  \item Sostituiamo le relationship Molti a Molti, tipicamente introducendo una nuova tabella
  \item Sostituiamo eventuali relazioni is-a.
  \item Selezioniamo o introduciamo le chiavi primarie.
  \item Aggiungiamo in modo controllato della ridondanza, se necessario per questioni di performance (Es. un campo precalcolato in caso di accessi frequenti a un dato derivato).
  \item Introduciamo ulteriori vincoli esterni in seguito alla ristrutturazione, se lo schema ristrutturato non rispetta pi\`u i vincoli dello schema originale.
\end{itemize}
\begin{figure}[H]
  \centering
  \includegraphics[width=13cm]{images/db-diagrams/er-diagram-ristrutturato.png}
  \caption{Schema Entity-Relationship tradotto}
\end{figure}

\section{Traduzione dello schema ristrutturato}
Traduciamo lo schema ristrutturato nello schema relazionale da inserire in PostgreSQL, con chiavi primarie e chiavi esterne.

\subsubsection{Tabella Movimento}
Come chiave primaria scegliamo uuid, campo univoco gi\`a presente all'interno dello schema concettuale. Inseriamo inoltre le chiavi esterne di Wallet e TipoOperazione,
necessarie per rappresentare le relationship wal\_mov e mov\_op.

\textbf{Movimento(\underline{uuid}, importo, dataEsecuzione, descrizione, idWorkflow*,\\ tipoOperazioneId, walletId) \\}
\textbf{\hspace*{1.5 cm} foreign key: $ Movimento[tipoOperazioneId] \subseteq TipoOperazione[nome] $} \\
\textbf{\hspace*{1.5 cm} foreign key: $ Movimento[walletId] \subseteq Wallet[id] $ }

\subsubsection{Tabella TipoOperazione}
Come chiave primaria scegliamo nome, campo univoco gi\`a presente. Inseriamo inoltre la chiave esterna di Servizio per rappresentare la relationship ser\_op.

\textbf{TipoOperazione(\underline{nome}, servizio, categoriaOperazione, costoReale, \\descrizione) \\}
\textbf{\hspace*{1.5 cm} foreign key: $ TipoOperazione[servizio] \subseteq Servizio[nome] $}

\subsubsection{Tabella Servizio}
Come chiave primaria scegliamo nome, campo univoco gi\`a presente.

\textbf{Servizio(\underline{nome})}

\subsubsection{Tabella Wallet}
Dato che non \`e presente nessun campo univoco utilizzabile come chiave primaria, inseriamo un campo intero generato da una sequenza. Inseriamo inoltre la chiave esterna
di Tenant per rappresentare la relationship ten\_wal.
\`E stato deciso di disporre un campo calcolato attraverso una task disposta sul servizio, che ogni ora prende tutte le nuove operazioni e le utilizza per
calcolare il nuovo saldo. Per avere comunque un saldo sempre aggiornato nelle operazioni importanti, viene salvata anche la data dell'operazione pi√π recente. Questa viene
utilizzata per recuperare tutti i movimenti successivi e calcolarne il parziale, per poi aggiungerlo al saldo salvato nella tabella.

\textbf{Wallet(\underline{id}, saldo, dataUltimaOperazione, tenantId) \\}
\textbf{\hspace*{1.5 cm} key:} \textit{(tenantId)} \\
\textbf{\hspace*{1.5 cm} foreign key: $ Wallet[tenantId] \subseteq Tenant[id] $}

\subsubsection{Tabella Tenant}
Dato che non \`e presente nessun campo univoco utilizzabile come chiave primaria, inseriamo un campo intero generato da una sequenza. Inseriamo inoltre la chiave esterna
di Listino per rappresentare la relationship ten\_lis

\textbf{Tenant(\underline{id}, listinoId) \\}
\textbf{\hspace*{1.5 cm} foreign key: $ Tenant[listinoId] \subseteq Listino[id] $}

\subsubsection{Tabella Listino}
Dato che non \`e presente nessun campo univoco utilizzabile come chiave primaria, inseriamo un campo intero generato da una sequenza.

\textbf{Listino(\underline{id}, descrizione, fasciaPrezzo)}

\subsubsection{Tabella PrezzoListino}
Per rappresentare la relationship Molti a Molti lis\_op, inseriamo un'altra tabella che ha come chiave primaria la combinazione delle chiavi esterne di Listino e TipoOperazione.

\textbf{PrezzoListino(\underline{tipoOperazioneId}, \underline{listinoId}, importo) \\}
\textbf{\hspace*{1.5 cm} foreign key: $ PrezzoListino[tipoOperazioneId] \subseteq TipoOperazione[nome] $} \\
\textbf{\hspace*{1.5 cm} foreign key: $ PrezzoListino[listinoId] \subseteq Listino[id] $}

\begin{figure}[H]
  \centering
  \includegraphics[width=13cm]{images/db-diagrams/rappresentazione-grafica-db.png}
  \caption{Rappresentazione grafica del database}
\end{figure}

\section{Traduzione dei vincoli esterni}
Visto che non sono stati aggiunti ulteriori vincoli esterni durante la ristrutturazione, resta da gestire l'unico vincolo riconosciuto durante la creazione
dello schema concettuale:
\\\\
\textbf{\label{tuttiimportitraduzione}Tutti gli importi specificati (\ref{tuttiimporticoncept})} - Si \`e deciso di gestire il vincolo attraverso il form di creazione, come descritto
nella \textbf{Sezione \ref{crealistinosection}}. Non \`e stato utilizzato un trigger di PostgreSQL per permettere l'inserimento di un Tipo Operazione senza dover necessariamente
aggiornare tutti i listini prezzi, che useranno una maggiorazione predefinita rispetto al Costo Reale finch\'e non verr\`a specificato un importo.

\section {Tabelle pre-popolate}
Ci sono due tabelle di cui conosciamo il contenuto a priori, e che non \`e possibile modificare da interfaccia: TipoOperazione e Servizio. Pertanto, inseriremo dei dati per popolarle
durante l'inizializzazione del database.
